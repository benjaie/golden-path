"use strict";(globalThis.webpackChunk_graphql_golden_path=globalThis.webpackChunk_graphql_golden_path||[]).push([[289],{5875(e,t,n){n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"pattern/batch-resolvers","title":"Batch resolvers","description":"Summary","source":"@site/docs/pattern/batch-resolvers.md","sourceDirName":"pattern","slug":"/pattern/batch-resolvers","permalink":"/pattern/batch-resolvers","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Batch resolvers"},"sidebar":"goldenPathSidebar","previous":{"title":"GraphQL Golden Path","permalink":"/"},"next":{"title":"Batching and caching (DataLoader)","permalink":"/pattern/batching-caching"}}');var r=n(4848),i=n(8453);const a={title:"Batch resolvers"},l=void 0,d={},o=[{value:"Summary",id:"summary",level:2},{value:"Applies to",id:"applies-to",level:2},{value:"Configuration (suggested defaults)",id:"configuration-suggested-defaults",level:2},{value:"Implementation notes",id:"implementation-notes",level:2},{value:"Cautions",id:"cautions",level:2},{value:"Why this is the recommended default",id:"why-this-is-the-recommended-default",level:2},{value:"Why users might opt out",id:"why-users-might-opt-out",level:2},{value:"Problems addressed",id:"problems-addressed",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(t.p,{children:"Batch resolvers group many field resolutions into a single call so servers avoid N+1 database or service requests while preserving GraphQL\u2019s shape."}),"\n",(0,r.jsx)(t.h2,{id:"applies-to",children:"Applies to"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"GraphQL servers"}),"\n",(0,r.jsx)(t.li,{children:"Execution engines and runtimes"}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"configuration-suggested-defaults",children:"Configuration (suggested defaults)"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Parameter"}),(0,r.jsx)(t.th,{children:"Default"}),(0,r.jsx)(t.th,{children:"Notes"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"batchSchedule"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"microtask"})}),(0,r.jsx)(t.td,{children:"Queue batching within the same tick."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"cacheScope"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"perRequest"})}),(0,r.jsx)(t.td,{children:"Avoid cross-request caching by default."})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"implementation-notes",children:"Implementation notes"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Resolver signature should accept a list of parent objects."}),"\n",(0,r.jsx)(t.li,{children:"Preserve positional ordering between inputs and outputs."}),"\n",(0,r.jsxs)(t.li,{children:["Return ",(0,r.jsx)(t.code,{children:"null"})," or errors for missing items without reordering."]}),"\n",(0,r.jsx)(t.li,{children:"Prefer request-scoped caching for de-duplication within the same operation."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"cautions",children:"Cautions"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Cross-request caches can leak data if not keyed by auth context."}),"\n",(0,r.jsx)(t.li,{children:"Make batch failures granular; avoid failing the entire batch when possible."}),"\n",(0,r.jsx)(t.li,{children:"Batching can increase end-to-end latency by expanding the critical path, even when backend requests are more efficient."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"why-this-is-the-recommended-default",children:"Why this is the recommended default"}),"\n",(0,r.jsx)(t.p,{children:"Batch resolvers remove N+1 by default and make the efficient path the path of least resistance. Users have to actively opt out to reintroduce per-item resolution, which keeps first-time integrations safer."}),"\n",(0,r.jsx)(t.h2,{id:"why-users-might-opt-out",children:"Why users might opt out"}),"\n",(0,r.jsx)(t.p,{children:"Users might prefer DataLoader, query planning, or another batching strategy instead of batch resolvers. DataLoader is a suitable alternative if it is applied consistently to every field that can trigger N+1 behavior."}),"\n",(0,r.jsxs)(t.p,{children:["The main risk with alternative approaches is ",(0,r.jsx)(t.strong,{children:"batch desynchronization"}),": if some fields use batching and others do not, parent objects can resolve at different times, fragmenting downstream batches and reducing effectiveness. Batch resolvers keep related items aligned, which reduces the risk of fragmented downstream batching."]}),"\n",(0,r.jsx)(t.h2,{id:"problems-addressed",children:"Problems addressed"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"/problem/n-plus-1",children:"N+1 queries"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453(e,t,n){n.d(t,{R:()=>a,x:()=>l});var s=n(6540);const r={},i=s.createContext(r);function a(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);